AWSTemplateFormatVersion: '2010-09-09'
Description: 'Week 3: RAG Pipeline for Enterprise Support - With S3 Vectors Knowledge Base'

Parameters:
  ProjectName:
    Type: String
    Default: rag-pipeline
    Description: Name prefix for all resources
  
  DeploymentSuffix:
    Type: String
    Default: ''
    Description: Optional suffix for resource names (useful for testing multiple deployments)
  
  EmbeddingModelId:
    Type: String
    Default: amazon.titan-embed-text-v2:0
    Description: Bedrock embedding model for the knowledge base

Resources:
  # =============================================================================
  # S3 Bucket for Knowledge Base Content (Source Documents)
  # =============================================================================
  KnowledgeBaseBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${ProjectName}-kb-${AWS::AccountId}-${AWS::Region}${DeploymentSuffix}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Project
          Value: !Ref ProjectName

  # =============================================================================
  # S3 Bucket for Frontend Hosting (Private - accessed via CloudFront)
  # =============================================================================
  FrontendBucket:
    Type: AWS::S3::Bucket
    Properties:
      BucketName: !Sub '${ProjectName}-frontend-${AWS::AccountId}-${AWS::Region}${DeploymentSuffix}'
      BucketEncryption:
        ServerSideEncryptionConfiguration:
          - ServerSideEncryptionByDefault:
              SSEAlgorithm: AES256
      PublicAccessBlockConfiguration:
        BlockPublicAcls: true
        BlockPublicPolicy: true
        IgnorePublicAcls: true
        RestrictPublicBuckets: true
      Tags:
        - Key: Project
          Value: !Ref ProjectName

  # =============================================================================
  # CloudFront Origin Access Control (OAC) for S3
  # =============================================================================
  CloudFrontOAC:
    Type: AWS::CloudFront::OriginAccessControl
    Properties:
      OriginAccessControlConfig:
        Name: !Sub '${ProjectName}-oac${DeploymentSuffix}'
        OriginAccessControlOriginType: s3
        SigningBehavior: always
        SigningProtocol: sigv4

  # =============================================================================
  # S3 Bucket Policy - Allow CloudFront OAC access only
  # =============================================================================
  FrontendBucketPolicy:
    Type: AWS::S3::BucketPolicy
    Properties:
      Bucket: !Ref FrontendBucket
      PolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Sid: AllowCloudFrontServicePrincipal
            Effect: Allow
            Principal:
              Service: cloudfront.amazonaws.com
            Action: s3:GetObject
            Resource: !Sub '${FrontendBucket.Arn}/*'
            Condition:
              StringEquals:
                AWS:SourceArn: !Sub 'arn:aws:cloudfront::${AWS::AccountId}:distribution/${CloudFrontDistribution}'

  # =============================================================================
  # CloudFront Distribution
  # =============================================================================
  CloudFrontDistribution:
    Type: AWS::CloudFront::Distribution
    Properties:
      DistributionConfig:
        Enabled: true
        DefaultRootObject: index.html
        Comment: !Sub '${ProjectName} Frontend Distribution'
        Origins:
          - Id: S3Origin
            DomainName: !GetAtt FrontendBucket.RegionalDomainName
            S3OriginConfig:
              OriginAccessIdentity: ''
            OriginAccessControlId: !Ref CloudFrontOAC
        DefaultCacheBehavior:
          TargetOriginId: S3Origin
          ViewerProtocolPolicy: redirect-to-https
          AllowedMethods: [GET, HEAD, OPTIONS]
          CachedMethods: [GET, HEAD]
          CachePolicyId: 658327ea-f89d-4fab-a63d-7e88639e58f6
          Compress: true
        CustomErrorResponses:
          - ErrorCode: 403
            ResponseCode: 200
            ResponsePagePath: /index.html
          - ErrorCode: 404
            ResponseCode: 200
            ResponsePagePath: /index.html
        PriceClass: PriceClass_100
        HttpVersion: http2
      Tags:
        - Key: Project
          Value: !Ref ProjectName

  # =============================================================================
  # S3 Vector Bucket for Vector Embeddings Storage
  # =============================================================================
  VectorBucket:
    Type: AWS::S3Vectors::VectorBucket
    Properties:
      VectorBucketName: !Sub '${ProjectName}-vec${DeploymentSuffix}'

  # =============================================================================
  # S3 Vector Index for Knowledge Base
  # =============================================================================
  VectorIndex:
    Type: AWS::S3Vectors::Index
    Properties:
      VectorBucketArn: !GetAtt VectorBucket.VectorBucketArn
      IndexName: !Sub '${ProjectName}-idx${DeploymentSuffix}'
      DataType: float32
      Dimension: 1024
      DistanceMetric: cosine
      MetadataConfiguration:
        NonFilterableMetadataKeys:
          - AMAZON_BEDROCK_TEXT
          - AMAZON_BEDROCK_METADATA

  # =============================================================================
  # IAM Role for Bedrock Knowledge Base
  # =============================================================================
  KnowledgeBaseRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-kb-role${DeploymentSuffix}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: bedrock.amazonaws.com
            Action: sts:AssumeRole
            Condition:
              StringEquals:
                aws:SourceAccount: !Ref AWS::AccountId
              ArnLike:
                aws:SourceArn: !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*'
      Policies:
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !GetAtt KnowledgeBaseBucket.Arn
                  - !Sub '${KnowledgeBaseBucket.Arn}/*'
        - PolicyName: BedrockModelAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                Resource:
                  - !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/${EmbeddingModelId}'
        - PolicyName: S3VectorsAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3vectors:CreateIndex
                  - s3vectors:DeleteIndex
                  - s3vectors:GetIndex
                  - s3vectors:ListIndexes
                  - s3vectors:PutVectors
                  - s3vectors:GetVectors
                  - s3vectors:DeleteVectors
                  - s3vectors:QueryVectors
                  - s3vectors:ListVectors
                Resource:
                  - !Sub 'arn:aws:s3vectors:${AWS::Region}:${AWS::AccountId}:bucket/${ProjectName}-vec${DeploymentSuffix}'
                  - !Sub 'arn:aws:s3vectors:${AWS::Region}:${AWS::AccountId}:bucket/${ProjectName}-vec${DeploymentSuffix}/index/*'

  # =============================================================================
  # Bedrock Knowledge Base (S3 Vectors)
  # =============================================================================
  KnowledgeBase:
    Type: AWS::Bedrock::KnowledgeBase
    Properties:
      Name: !Sub '${ProjectName}-kb${DeploymentSuffix}'
      Description: 'Enterprise support knowledge base for RAG pipeline using S3 Vectors'
      RoleArn: !GetAtt KnowledgeBaseRole.Arn
      KnowledgeBaseConfiguration:
        Type: VECTOR
        VectorKnowledgeBaseConfiguration:
          EmbeddingModelArn: !Sub 'arn:aws:bedrock:${AWS::Region}::foundation-model/${EmbeddingModelId}'
      StorageConfiguration:
        Type: S3_VECTORS
        S3VectorsConfiguration:
          VectorBucketArn: !GetAtt VectorBucket.VectorBucketArn
          IndexArn: !GetAtt VectorIndex.IndexArn
      Tags:
        Project: !Ref ProjectName

  # =============================================================================
  # Knowledge Base Data Source
  # =============================================================================
  KnowledgeBaseDataSource:
    Type: AWS::Bedrock::DataSource
    Properties:
      Name: !Sub '${ProjectName}-datasource${DeploymentSuffix}'
      Description: 'S3 data source for support documentation'
      KnowledgeBaseId: !Ref KnowledgeBase
      DataSourceConfiguration:
        Type: S3
        S3Configuration:
          BucketArn: !GetAtt KnowledgeBaseBucket.Arn
      VectorIngestionConfiguration:
        ChunkingConfiguration:
          ChunkingStrategy: FIXED_SIZE
          FixedSizeChunkingConfiguration:
            MaxTokens: 512
            OverlapPercentage: 20

  # =============================================================================
  # IAM Role for Lambda Function
  # =============================================================================
  LambdaExecutionRole:
    Type: AWS::IAM::Role
    Properties:
      RoleName: !Sub '${ProjectName}-lambda-role${DeploymentSuffix}'
      AssumeRolePolicyDocument:
        Version: '2012-10-17'
        Statement:
          - Effect: Allow
            Principal:
              Service: lambda.amazonaws.com
            Action: sts:AssumeRole
      ManagedPolicyArns:
        - arn:aws:iam::aws:policy/service-role/AWSLambdaBasicExecutionRole
      Policies:
        - PolicyName: BedrockAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:InvokeModel
                  - bedrock:Retrieve
                  - bedrock:RetrieveAndGenerate
                Resource: '*'
        - PolicyName: BedrockAgentAccess
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - bedrock:StartIngestionJob
                  - bedrock:GetIngestionJob
                Resource:
                  - !Sub 'arn:aws:bedrock:${AWS::Region}:${AWS::AccountId}:knowledge-base/*'
        - PolicyName: S3Access
          PolicyDocument:
            Version: '2012-10-17'
            Statement:
              - Effect: Allow
                Action:
                  - s3:PutObject
                  - s3:GetObject
                  - s3:ListBucket
                Resource:
                  - !GetAtt KnowledgeBaseBucket.Arn
                  - !Sub '${KnowledgeBaseBucket.Arn}/*'

  # =============================================================================
  # Lambda Function for RAG Queries
  # =============================================================================
  QueryFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-query${DeploymentSuffix}'
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 60
      MemorySize: 512
      Environment:
        Variables:
          KNOWLEDGE_BASE_ID: !Ref KnowledgeBase
          DEFAULT_MODEL_ID: 'us.anthropic.claude-sonnet-4-5-20250929-v1:0'
      Code:
        ZipFile: |
          import json
          import boto3
          import os
          
          bedrock_agent = boto3.client('bedrock-agent-runtime')
          bedrock = boto3.client('bedrock-runtime')
          
          # Map model IDs to inference profile IDs for models that require them
          INFERENCE_PROFILE_MAP = {
              'anthropic.claude-sonnet-4-5-20250929-v1:0': 'us.anthropic.claude-sonnet-4-5-20250929-v1:0',
              'anthropic.claude-sonnet-4-20250514-v1:0': 'us.anthropic.claude-sonnet-4-20250514-v1:0',
              'anthropic.claude-3-5-sonnet-20241022-v2:0': 'us.anthropic.claude-3-5-sonnet-20241022-v2:0',
              'anthropic.claude-3-5-sonnet-20240620-v1:0': 'us.anthropic.claude-3-5-sonnet-20240620-v1:0',
          }
          
          def get_model_id_for_rag(model_id):
              # For RetrieveAndGenerate, cross-region inference profiles can use just the ID
              # If already an inference profile ID, use it directly
              if model_id.startswith('us.') or model_id.startswith('eu.'):
                  return model_id
              # Check if model needs inference profile
              if model_id in INFERENCE_PROFILE_MAP:
                  return INFERENCE_PROFILE_MAP[model_id]
              # Standard foundation model - use model ID directly
              return model_id
          
          def get_invoke_model_id(model_id):
              # If already an inference profile, use it
              if model_id.startswith('us.') or model_id.startswith('eu.'):
                  return model_id
              # Check if model needs inference profile
              return INFERENCE_PROFILE_MAP.get(model_id, model_id)
          
          def handler(event, context):
              if event.get('httpMethod') == 'OPTIONS' or event.get('requestContext', {}).get('http', {}).get('method') == 'OPTIONS':
                  return cors_response(200, {})
              
              try:
                  body = json.loads(event.get('body', '{}'))
                  query = body.get('query', '')
                  use_rag = body.get('useRag', True)
                  kb_id = body.get('knowledgeBaseId') or os.environ.get('KNOWLEDGE_BASE_ID')
                  model_id = body.get('modelId') or os.environ.get('DEFAULT_MODEL_ID')
                  system_prompt = body.get('systemPrompt') or 'You are an AWS support specialist. Provide accurate, helpful responses.'
                  
                  if use_rag and kb_id and kb_id != 'PLACEHOLDER':
                      response = query_with_rag(query, kb_id, model_id, system_prompt)
                  else:
                      response = query_without_rag(query, model_id, system_prompt)
                  
                  return cors_response(200, response)
              except Exception as e:
                  print(f"Error: {str(e)}")
                  return cors_response(500, {'error': str(e)})
          
          def query_with_rag(query, kb_id, model_id, system_prompt):
              # For RetrieveAndGenerate, use the model/inference profile ID directly
              rag_model_id = get_model_id_for_rag(model_id)
              
              response = bedrock_agent.retrieve_and_generate(
                  input={'text': query},
                  retrieveAndGenerateConfiguration={
                      'type': 'KNOWLEDGE_BASE',
                      'knowledgeBaseConfiguration': {
                          'knowledgeBaseId': kb_id,
                          'modelArn': rag_model_id,
                          'generationConfiguration': {
                              'promptTemplate': {
                                  'textPromptTemplate': system_prompt + '\n\nContext:\n$search_results$\n\nQuestion: $query$\n\nAnswer:'
                              }
                          }
                      }
                  }
              )
              
              citations = []
              for citation in response.get('citations', []):
                  for ref in citation.get('retrievedReferences', []):
                      loc = ref.get('location', {}).get('s3Location', {})
                      citations.append({
                          'uri': loc.get('uri', ''),
                          'text': ref.get('content', {}).get('text', '')[:200]
                      })
              
              return {
                  'response': response['output']['text'],
                  'citations': citations,
                  'mode': 'RAG',
                  'model': model_id
              }
          
          def query_without_rag(query, model_id, system_prompt):
              invoke_model_id = get_invoke_model_id(model_id)
              
              response = bedrock.invoke_model(
                  modelId=invoke_model_id,
                  body=json.dumps({
                      'anthropic_version': 'bedrock-2023-05-31',
                      'max_tokens': 2048,
                      'system': system_prompt,
                      'messages': [{'role': 'user', 'content': query}]
                  })
              )
              
              result = json.loads(response['body'].read())
              return {
                  'response': result['content'][0]['text'],
                  'mode': 'Direct',
                  'model': model_id
              }
          
          def cors_response(status_code, body):
              return {
                  'statusCode': status_code,
                  'headers': {
                      'Content-Type': 'application/json',
                      'Access-Control-Allow-Origin': '*',
                      'Access-Control-Allow-Headers': 'Content-Type,Authorization',
                      'Access-Control-Allow-Methods': 'OPTIONS,POST,GET'
                  },
                  'body': json.dumps(body)
              }

  # =============================================================================
  # Custom Resource Lambda for Ingestion
  # =============================================================================
  IngestionFunction:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: !Sub '${ProjectName}-ingestion${DeploymentSuffix}'
      Runtime: python3.11
      Handler: index.handler
      Role: !GetAtt LambdaExecutionRole.Arn
      Timeout: 300
      MemorySize: 256
      Environment:
        Variables:
          KNOWLEDGE_BASE_ID: !Ref KnowledgeBase
          DATA_SOURCE_ID: !GetAtt KnowledgeBaseDataSource.DataSourceId
      Code:
        ZipFile: |
          import json
          import boto3
          import cfnresponse
          import os
          import time
          
          bedrock_agent = boto3.client('bedrock-agent')
          
          def handler(event, context):
              print(f"Event: {json.dumps(event)}")
              
              if event['RequestType'] == 'Delete':
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {})
                  return
              
              try:
                  kb_id = os.environ['KNOWLEDGE_BASE_ID']
                  ds_id = os.environ['DATA_SOURCE_ID']
                  
                  response = bedrock_agent.start_ingestion_job(
                      knowledgeBaseId=kb_id,
                      dataSourceId=ds_id
                  )
                  
                  job_id = response['ingestionJob']['ingestionJobId']
                  print(f"Started ingestion job: {job_id}")
                  
                  max_wait = 240
                  waited = 0
                  while waited < max_wait:
                      time.sleep(10)
                      waited += 10
                      
                      status_response = bedrock_agent.get_ingestion_job(
                          knowledgeBaseId=kb_id,
                          dataSourceId=ds_id,
                          ingestionJobId=job_id
                      )
                      
                      status = status_response['ingestionJob']['status']
                      print(f"Ingestion status: {status}")
                      
                      if status == 'COMPLETE':
                          cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                              'IngestionJobId': job_id,
                              'Status': 'COMPLETE'
                          })
                          return
                      elif status == 'FAILED':
                          cfnresponse.send(event, context, cfnresponse.FAILED, {
                              'Error': 'Ingestion job failed'
                          })
                          return
                  
                  cfnresponse.send(event, context, cfnresponse.SUCCESS, {
                      'IngestionJobId': job_id,
                      'Status': 'IN_PROGRESS'
                  })
                  
              except Exception as e:
                  print(f"Error: {str(e)}")
                  cfnresponse.send(event, context, cfnresponse.FAILED, {
                      'Error': str(e)
                  })

  # =============================================================================
  # Custom Resource to Trigger Ingestion
  # =============================================================================
  TriggerIngestion:
    Type: Custom::TriggerIngestion
    DependsOn:
      - KnowledgeBaseDataSource
    Properties:
      ServiceToken: !GetAtt IngestionFunction.Arn
      Version: '1'

  # =============================================================================
  # API Gateway
  # =============================================================================
  ApiGateway:
    Type: AWS::ApiGatewayV2::Api
    Properties:
      Name: !Sub '${ProjectName}-api${DeploymentSuffix}'
      ProtocolType: HTTP
      CorsConfiguration:
        AllowOrigins: ['*']
        AllowMethods: [GET, POST, OPTIONS]
        AllowHeaders: ['*']

  ApiIntegration:
    Type: AWS::ApiGatewayV2::Integration
    Properties:
      ApiId: !Ref ApiGateway
      IntegrationType: AWS_PROXY
      IntegrationUri: !GetAtt QueryFunction.Arn
      PayloadFormatVersion: '2.0'

  ApiRoute:
    Type: AWS::ApiGatewayV2::Route
    Properties:
      ApiId: !Ref ApiGateway
      RouteKey: 'POST /query'
      Target: !Sub 'integrations/${ApiIntegration}'

  ApiStage:
    Type: AWS::ApiGatewayV2::Stage
    Properties:
      ApiId: !Ref ApiGateway
      StageName: prod
      AutoDeploy: true

  LambdaApiPermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !Ref QueryFunction
      Action: lambda:InvokeFunction
      Principal: apigateway.amazonaws.com
      SourceArn: !Sub 'arn:aws:execute-api:${AWS::Region}:${AWS::AccountId}:${ApiGateway}/*'

# =============================================================================
# Outputs
# =============================================================================
Outputs:
  KnowledgeBaseBucketName:
    Description: S3 bucket for knowledge base content
    Value: !Ref KnowledgeBaseBucket
    Export:
      Name: !Sub '${ProjectName}-kb-bucket'

  KnowledgeBaseId:
    Description: Bedrock Knowledge Base ID
    Value: !Ref KnowledgeBase

  DataSourceId:
    Description: Knowledge Base Data Source ID
    Value: !GetAtt KnowledgeBaseDataSource.DataSourceId

  VectorBucketArn:
    Description: S3 Vector Bucket ARN for embeddings
    Value: !GetAtt VectorBucket.VectorBucketArn

  VectorIndexArn:
    Description: S3 Vector Index ARN
    Value: !GetAtt VectorIndex.IndexArn

  FrontendBucketName:
    Description: S3 bucket for frontend hosting
    Value: !Ref FrontendBucket

  FrontendURL:
    Description: CloudFront distribution URL for frontend
    Value: !Sub 'https://${CloudFrontDistribution.DomainName}'

  CloudFrontDistributionId:
    Description: CloudFront distribution ID (for cache invalidation)
    Value: !Ref CloudFrontDistribution

  ApiEndpoint:
    Description: API Gateway endpoint URL
    Value: !Sub 'https://${ApiGateway}.execute-api.${AWS::Region}.amazonaws.com/prod'

  LambdaFunctionName:
    Description: Lambda function name
    Value: !Ref QueryFunction
